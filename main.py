from fastapi import FastAPI, Request, Depends, HTTPException, status
from fastapi.responses import StreamingResponse, RedirectResponse
from fastapi.templating import Jinja2Templates
from fastapi.staticfiles import StaticFiles
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel
from typing import List, Optional
from enum import Enum
from transformers import AutoModelForCausalLM, AutoTokenizer, TextIteratorStreamer
import torch
import threading
from datetime import datetime
import uuid
from pymongo import MongoClient
from jose import JWTError, jwt
from pydantic_settings import BaseSettings
import hmac
import hashlib


class Settings(BaseSettings):
    mongo_uri: str
    secret_key: str
    algorithm: str
    model: str
    dual_response_probability: float = 0.1  # Default value if not in .env

    # load from .env
    class Config:
        env_file = ".env"


settings = Settings()  # type: ignore


# Initialize FastAPI app
app = FastAPI()

# Set up templates directory
templates = Jinja2Templates(directory="templates")

# Set up static files (for CSS and JS)
app.mount("/static", StaticFiles(directory="static"), name="static")

# MongoDB Connection
try:
    client = MongoClient(settings.mongo_uri)
    db = client.llama_chat_db
    # Test connection
    client.admin.command("ping")
    print("MongoDB connection successful!")
except Exception as e:
    print(f"MongoDB connection error: {str(e)}")
    raise

# JWT settings
SECRET_KEY = settings.secret_key  # Change this in production
ALGORITHM = settings.algorithm
security = HTTPBearer()

# Model & tokenizer
model_name = settings.model
tokenizer = AutoTokenizer.from_pretrained(
    model_name,
)
model = AutoModelForCausalLM.from_pretrained(
    model_name,
    device_map="auto",
    torch_dtype=torch.bfloat16,
)


class RoleEnum(str, Enum):
    system = "system"
    user = "user"
    assistant = "assistant"


class Message(BaseModel):
    role: RoleEnum
    content: str


class MessageWithSignature(Message):
    signature: Optional[str] = None
    message_id: Optional[str] = None


class ChatHistory(BaseModel):
    chat_id: str
    title: str
    messages: List[dict]
    user_id: str
    created_at: datetime
    updated_at: datetime


class User(BaseModel):
    username: str


class UserInDB(User):
    user_id: str
    created_at: datetime


class TokenResponse(BaseModel):
    access_token: str
    token_type: str


# Create JWT token
def create_jwt_token(data: dict):
    to_encode = data.copy()
    token = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return token


# Generate message signature
def generate_message_signature(content: str) -> str:
    return hmac.new(SECRET_KEY.encode(), content.encode(), hashlib.sha256).hexdigest()


# Verify message signature
def verify_message_signature(content: str, signature: str) -> bool:
    expected_signature = generate_message_signature(content)
    return hmac.compare_digest(expected_signature, signature)


# Verify JWT token
async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
):
    try:
        payload = jwt.decode(
            credentials.credentials, SECRET_KEY, algorithms=[ALGORITHM]
        )
        username = payload.get("sub")
        if username is None:
            raise HTTPException(status_code=401, detail="Invalid token")

        user = db.users.find_one({"username": username})
        if not user:
            raise HTTPException(status_code=401, detail="User not found")

        # Convert ObjectId to string to make it JSON serializable
        if "_id" in user:
            user["_id"] = str(user["_id"])

        return user
    except JWTError as e:
        print(f"JWT Error: {str(e)}")
        raise HTTPException(status_code=401, detail="Invalid token")
    except Exception as e:
        print(f"Authentication error: {str(e)}")
        raise HTTPException(status_code=401, detail=f"Authentication error: {str(e)}")


def chat_stream(prompt: str):
    """
    Generator that yields tokens as they are generated by the model.
    """
    inputs = tokenizer(prompt, return_tensors="pt").to(model.device)
    streamer = TextIteratorStreamer(tokenizer, skip_prompt=True)  # type: ignore
    generation_kwargs = dict(
        **inputs,
        streamer=streamer,
        max_new_tokens=1024,
    )

    thread = threading.Thread(target=model.generate, kwargs=generation_kwargs)
    thread.start()

    # Track the full response to generate signature at the end
    full_response = ""

    for token in streamer:
        if "<|im_end|>" in token:
            token = token.replace("<|im_end|>", "")
        full_response += token
        yield token

    # After all tokens are generated, yield the signature as a special message
    message_id = str(uuid.uuid4())
    signature = generate_message_signature(full_response)
    signature_data = f"\n__MESSAGE_ID__:{message_id}\n__SIGNATURE__:{signature}"

    yield signature_data


@app.post("/api/register", response_model=TokenResponse)
async def register(user: User):
    # Check if username already exists
    existing_user = db.users.find_one({"username": user.username})
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Username already registered",
        )

    # Create new user
    user_id = str(uuid.uuid4())
    new_user = {
        "user_id": user_id,
        "username": user.username,
        "created_at": datetime.utcnow(),
    }

    # Insert into database
    db.users.insert_one(new_user)

    # Create and return JWT token
    access_token = create_jwt_token({"sub": user.username})
    return {"access_token": access_token, "token_type": "bearer"}


@app.post("/api/login", response_model=TokenResponse)
async def login(user: User):
    # Find the user
    db_user = db.users.find_one({"username": user.username})
    if not db_user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid username"
        )

    # Create and return JWT token
    access_token = create_jwt_token({"sub": user.username})
    return {"access_token": access_token, "token_type": "bearer"}


@app.post("/api/chat")
async def chat_endpoint(messages: List[Message], user=Depends(get_current_user)):
    """
    Accepts a list of conversation messages:
        [ {role: "system"|"user"|"assistant", content: "..."} ]
    Returns streaming tokens for the assistant's newest response.
    """
    # Convert our Message objects to the format expected by the tokenizer
    chat_messages = [{"role": msg.role, "content": msg.content} for msg in messages]

    system_prompt = (
        "You are a medical assistant trained to provide general health information. "
        "If user says something unrelated to medical, just say 'I am a medical assistant, I can only answer medical questions.' "
    )

    # Use the model's built-in chat template
    prompt = tokenizer.apply_chat_template(
        [{"role": "system", "content": system_prompt}, *chat_messages],
        tokenize=False,
        add_generation_prompt=True,
    )

    return StreamingResponse(chat_stream(prompt), media_type="text/plain")  # type: ignore


class ChatCreate(BaseModel):
    title: str


@app.post("/api/chats")
async def create_chat(chat_data: ChatCreate, user=Depends(get_current_user)):
    """Create a new chat"""
    chat_id = str(uuid.uuid4())
    chat = {
        "id": chat_id,  # Use 'id' instead of 'chat_id' to match existing index
        "title": chat_data.title,
        "messages": [],
        "user_id": user["user_id"],
        "created_at": datetime.utcnow(),
        "updated_at": datetime.utcnow(),
    }

    try:
        db.chats.insert_one(chat)
        return {"chat_id": chat_id, "title": chat_data.title}
    except Exception as e:
        print(f"Error creating chat: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")


@app.get("/api/chats")
async def get_chats(user=Depends(get_current_user)):
    """Get all chats for the current user"""
    chats = list(db.chats.find({"user_id": user["user_id"]}).sort("updated_at", -1))

    # Convert ObjectId to string for JSON serialization
    for chat in chats:
        if "_id" in chat:
            chat["_id"] = str(chat["_id"])
        if "created_at" in chat:
            chat["created_at"] = chat["created_at"].isoformat()
        if "updated_at" in chat:
            chat["updated_at"] = chat["updated_at"].isoformat()

        # Add chat_id for backward compatibility if using id field
        if "id" in chat and "chat_id" not in chat:
            chat["chat_id"] = chat["id"]

    return chats


@app.get("/api/chats/{chat_id}")
async def get_chat(chat_id: str, user=Depends(get_current_user)):
    """Get a specific chat by ID"""
    chat = db.chats.find_one(
        {
            "$or": [
                {"chat_id": chat_id, "user_id": user["user_id"]},
                {"id": chat_id, "user_id": user["user_id"]},
            ]
        }
    )

    if not chat:
        raise HTTPException(status_code=404, detail="Chat not found")

    # Convert ObjectId to string for JSON serialization
    if "_id" in chat:
        chat["_id"] = str(chat["_id"])
    if "created_at" in chat:
        chat["created_at"] = chat["created_at"].isoformat()
    if "updated_at" in chat:
        chat["updated_at"] = chat["updated_at"].isoformat()

    # Add chat_id for backward compatibility if using id field
    if "id" in chat and "chat_id" not in chat:
        chat["chat_id"] = chat["id"]

    return chat


class MessageAdd(BaseModel):
    message: MessageWithSignature


@app.post("/api/chats/{chat_id}/messages")
async def add_message(
    chat_id: str, message_data: MessageAdd, user=Depends(get_current_user)
):
    """Add a single new message to the chat"""
    # Verify the chat belongs to the user
    chat = db.chats.find_one(
        {
            "$or": [
                {"chat_id": chat_id, "user_id": user["user_id"]},
                {"id": chat_id, "user_id": user["user_id"]},
            ]
        }
    )

    if not chat:
        raise HTTPException(status_code=404, detail="Chat not found")

    # Determine which field to use in update
    id_field = "id" if "id" in chat else "chat_id"

    # Validate the message
    message = message_data.message

    # Prepare message for storage
    message_dict = {"role": message.role, "content": message.content}

    # Validate based on role
    if message.role == "assistant":
        if not message.signature or not message.message_id:
            raise HTTPException(
                status_code=400,
                detail="Assistant messages require signature and message_id",
            )

        # Verify the signature
        if not verify_message_signature(message.content, message.signature):
            raise HTTPException(status_code=400, detail="Invalid message signature")

        # Add signature and ID to stored message
        message_dict["signature"] = message.signature
        message_dict["message_id"] = message.message_id

    elif message.role == "user":
        # User messages don't need additional validation
        pass
    else:
        # System messages should not be added via this endpoint
        raise HTTPException(
            status_code=400, detail="Cannot add system messages through this endpoint"
        )

    # Update messages and timestamp
    db.chats.update_one(
        {id_field: chat_id},
        {
            "$push": {"messages": message_dict},
            "$set": {"updated_at": datetime.utcnow()},
        },
    )

    return {"status": "message added"}


@app.get("/")
async def root():
    """Redirect to login page"""
    return RedirectResponse(url="/login")


@app.get("/login")
async def login_page(request: Request):
    """Serve login page"""
    return templates.TemplateResponse("login.html", {"request": request})


@app.get("/register")
async def register_page(request: Request):
    """Serve registration page"""
    return templates.TemplateResponse("register.html", {"request": request})


@app.get("/home")
async def home_page(request: Request):
    """Serve main chat UI"""
    return templates.TemplateResponse("home.html", {"request": request})


@app.get("/chat")
async def chat_ui(request: Request):
    """Serve main chat UI"""
    return templates.TemplateResponse(
        "chat.html",
        {
            "request": request,
            "dual_response_probability": settings.dual_response_probability,
        },
    )


# Also update the chat_by_id endpoint
@app.get("/chat/{chat_id}")
async def chat_by_id(request: Request, chat_id: str):
    """Serve specific chat by ID"""
    return templates.TemplateResponse(
        "chat.html",
        {
            "request": request,
            "chat_id": chat_id,
            "dual_response_probability": settings.dual_response_probability,
        },
    )


# Add these new classes after the other model definitions
class PairwiseFeedback(BaseModel):
    prompt: str
    chosen_response: MessageWithSignature
    rejected_response: MessageWithSignature
    chat_id: str


# Add this new endpoint to store pairwise feedback
@app.post("/api/feedback/pairwise")
async def store_pairwise_feedback(
    feedback: PairwiseFeedback, user=Depends(get_current_user)
):
    """
    Store pairwise feedback for model improvement
    """
    try:
        # Verify the chat belongs to the user
        chat = db.chats.find_one(
            {
                "$or": [
                    {"chat_id": feedback.chat_id, "user_id": user["user_id"]},
                    {"id": feedback.chat_id, "user_id": user["user_id"]},
                ]
            }
        )

        if not chat:
            raise HTTPException(status_code=404, detail="Chat not found")

        # Get the conversation history up to the prompt
        conversation_history = []
        for msg in chat.get("messages", []):
            conversation_history.append(msg)

        # Find the last user message (which should be the prompt)
        # In case there are multiple interactions, we want to make sure
        # we're using the right prompt that generated these two responses

        # Create the feedback documents
        chosen_conversation = conversation_history.copy()
        chosen_conversation.append({"role": "user", "content": feedback.prompt})
        chosen_conversation.append(
            {
                "role": "assistant",
                "content": feedback.chosen_response.content,
                "message_id": feedback.chosen_response.message_id,
                "signature": feedback.chosen_response.signature,
            }
        )

        rejected_conversation = conversation_history.copy()
        rejected_conversation.append({"role": "user", "content": feedback.prompt})
        rejected_conversation.append(
            {
                "role": "assistant",
                "content": feedback.rejected_response.content,
                "message_id": feedback.rejected_response.message_id,
                "signature": feedback.rejected_response.signature,
            }
        )

        # Store the feedback
        feedback_doc = {
            "user_id": user["user_id"],
            "chat_id": feedback.chat_id,
            "prompt": feedback.prompt,
            "chosen": chosen_conversation,
            "rejected": rejected_conversation,
            "timestamp": datetime.utcnow(),
        }

        # Insert into the pairwise_human_feedback collection
        db.pairwise_human_feedback.insert_one(feedback_doc)

        return {"status": "feedback stored"}
    except Exception as e:
        print(f"Error storing feedback: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error storing feedback: {str(e)}")
